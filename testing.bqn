s â† â€¢Import "./strings.bqn"

â€¢FLines "input/1.in"

x â† â€¢FLines âŠ‘ â€¢args

# want to split the list of lines on empty lines
# from BQNcrate:
#groups â† âŸ¨âŸ©((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)x
# âŠ” collect into groups: 1â€¿0â€¿1â€¿2â€¿2â€¿3â€¿3 âŠ” 4â€¿5â€¿6â€¿6â€¿4â€¿7â€¿5 == [[5] [4 6] [6 4] [7 5]]
# âŠ£ âŠ¢ as dyads return left and right operand respectively (left id, right id)
# = is elementwise equal
#âŸ¨âŸ©=x  # does not work because I need to specify that âŸ¨âŸ© is to be treated as an atom
#"1000"=x # even this does not work because "1000" is also a sequence
# idea: use Â¨ to manually map my operation
#{ğ•©="1000"}Â¨x # that does not work either because = is still elementwise within the map
# ğ•¨ â· ğ•© seems to be the way, which finds occurences of string ğ•¨ in superstring ğ•©
# however the empty string of course is a substring of every string
# (in future, â‰¡ (Match) is for equality)

# ok instead of checking for the empty string, check for length 0
# âŠ‘â‰¢ğ•© is ğ•©.shape[0]
# â‰ Â¨x would do the same thing
lengths â† {âŠ‘â‰¢ğ•©}Â¨x
emptylines â† lengths=0

# what is âŠ¢-Ëœ+`Ã—Â¬ ?
#   Â¬ logical not
#   Ã— sign or multiply
#   ` is reduce (left to right)
#   + is add
#   ğ”½Ëœ is swap arguments to ğ”½
#   - is negate or subtract
#   âŠ¢ right identity

# BQNcrate: a1(âŠ¢-Ëœ+`Ã—Â¬)âŠ¸âŠ”y  Split y at 1s in a1, not including cells of y at those locations
# âŠ” collect into groups: 1â€¿0â€¿1â€¿2â€¿2â€¿3â€¿3 âŠ” 4â€¿5â€¿6â€¿6â€¿4â€¿7â€¿5 == [[5] [4 6] [6 4] [7 5]]
# âŠ¸ is dyadic before: ğ•¨ ğ”½âŠ¸ğ”¾ ğ•© == (ğ”½ ğ•¨) ğ”¾ ğ•©
# so it kinda just reverses the visual ordering of ğ”½ and ğ•¨
# ğ•¨(âŠ¢-Ëœ+`Ã—Â¬)âŠ¸âŠ”ğ•© == ((âŠ¢-Ëœ+`Ã—Â¬)ğ•¨)âŠ”ğ•©
# need the extra parentheses, so âŠ¢-Ëœ+`Ã—Â¬ parsing depends
# (âŠ¢)-Ëœ(+`Ã—Â¬)  is how it parses
# same as (+`Ã—Â¬)-âŠ¢
# (+`Ã—(Â¬foo))-foo where foo is the argument
# ((+`foo)Ã—(Â¬foo))-foo is what it is
# so +`Ã—Â¬ parses to (+`)Ã—(Â¬) which is a little computation graph
# how does bqn know that Â¬ is not data, to which monadic Ã— is applied and then monadic +`?
# I guess Â¬ is never data unless marked otherwise. how?
groupsâ†emptylines(âŠ¢-Ëœ+`Ã—Â¬)âŠ¸âŠ”x

# next. parse each line into a number
# BQNcrate: (10âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½ -âŸœ'0')d1
# not sure why the compose âˆ˜ is needed
Parseintâ†{ğ•¨+10Ã—ğ•©}Â´âˆ˜âŒ½ -âŸœ'0'
numbers â† ParseintÂ¨Â¨ groups

maxsum â† âŒˆÂ´+Â´Â¨ numbers
â€¢Show maxsum

# for part two, want sum of top 3
sums â† +Â´Â¨ numbers
# taking topk efficiently according to BQNcrate:
# i0{(ğ•¨â†‘Â·â’âŠâŸœğ•©)âŠ¸âŠ/ğ•©â‰¥(ğ•¨-1)âŠ‘âˆ¨(âŒˆâˆ˜âˆšğ•¨âŠ¸Ã—)âŠ¸â€¢rand.Subsetâˆ˜â‰ âŠ¸âŠğ•©}n1
# sqrt?? random subset?? :-O  preposterous
# just implement it myself, use fold
top3 â† 0â€¿0â€¿0 {3â†‘âˆ¨ğ•¨âˆ¾ğ•©}Â´ sums
â€¢Show +Â´top3
