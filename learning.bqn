# Learning Notes
# Replicate / Indices 


/ 1â€¿2â€¿3â€¿4 # âŸ¨ 0 1 1 2 2 2 3 3 3 3 âŸ©

# Here we get a new list with the indices repeated based on the list
# Replicate is more useful I think because you can filter with it

1â€¿0â€¿1 / "abc" # "ac"

# This is saying 'repeat index 0 once, 1 zero times, and 1 once
# it's cool because it's more capable than just filter but the
# 'base case' so to speak is a filter, like this

{ğ•© > 3}âŠ¸/ â†•10 # âŸ¨ 4 5 6 7 8 9 âŸ©

# so there are a couple things here, the range (â†•) is being used
# to essentially make a list of that ğ•© length
# the bind/before âŠ¸ here is saying 'before replicate, apply ğ”½
# which in this case is a function block that checks if ğ•© is greater
# than 3 

# I can be more tacit with this, as most BQN should generally avoid
# placeholder variables in these situations I can do that with after âŸœ

>âŸœ3âŠ¸/ â†•10 # âŸ¨ 4 5 6 7 8 9 âŸ©

# So for an advent of code problem I start with a list of strings

list â† âŸ¨"1000","2000","3000",âŸ¨âŸ©,"4000",âŸ¨âŸ©,"5000","6000",âŸ¨âŸ©,"7000","8000","9000",âŸ¨âŸ©,"10000" âŸ©

# and I need to split it based on the empty list
# BQN Crate has this 

Split â† (âŠ¢-Ëœ+`Ã—Â¬)âŠ¸âŠ”

# Which I can tacit expand to this:

lengths â† 0=(âŠ‘â‰¢)Â¨ list

lengths Split list

(âŠ¢-Ëœ+`Ã—Â¬) lengths

chunks â† (((+` lengths) Ã— Â¬lengths) - lengths) âŠ” list

nums â† â€¢ParseFloatÂ¨Â¨ chunks

âŒˆÂ´>+Â´Â¨ nums

# Takes an array and returns the first and last element
FirstAndLast â† { âŠâ‰(ğ•©â‰ âŒ½ğ•©)}
FirstAndLast â†• 10 # âŸ¨ 0 9 âŸ©

# âŒ½ reverses the list ğ•©
# â‰ couples the original list ğ•© with the reversed â‰ğ•©
{ğ•© â‰ âŒ½ğ•©} â†•10
# â”Œâ”€                     
# â•µ 0 1 2 3 4 5 6 7 8 9  
#   9 8 7 6 5 4 3 2 1 0  
#                      â”˜

# â‰ transposes the array
# âŠ picks the first major cell

{âŠâ‰(ğ•© â‰ âŒ½ğ•©)} â†•10

# âŸ¨0 9âŸ©