# Learning Notes
# Replicate / Indices 


/ 1â€¿2â€¿3â€¿4 # âŸ¨ 0 1 1 2 2 2 3 3 3 3 âŸ©

# Here we get a new list with the indices repeated based on the list
# Replicate is more useful I think because you can filter with it

1â€¿0â€¿1 / "abc" # "ac"

# This is saying 'repeat index 0 once, 1 zero times, and 1 once
# it's cool because it's more capable than just filter but the
# 'base case' so to speak is a filter, like this

{ğ•© > 3}âŠ¸/ â†•10 # âŸ¨ 4 5 6 7 8 9 âŸ©

# so there are a couple things here, the range (â†•) is being used
# to essentially make a list of that ğ•© length
# the bind/before âŠ¸ here is saying 'before replicate, apply ğ”½
# which in this case is a function block that checks if ğ•© is greater
# than 3 

# I can be more tacit with this, as most BQN should generally avoid
# placeholder variables in these situations I can do that with after âŸœ

>âŸœ3âŠ¸/ â†•10 # âŸ¨ 4 5 6 7 8 9 âŸ©

# So for an advent of code problem I start with a list of strings

list â† âŸ¨"1000","2000","3000",âŸ¨âŸ©,"4000",âŸ¨âŸ©,"5000","6000",âŸ¨âŸ©,"7000","8000","9000",âŸ¨âŸ©,"10000" âŸ©

# and I need to split it based on the empty list
# BQN Crate has this 

Split â† (âŠ¢-Ëœ+`Ã—Â¬)âŠ¸âŠ”

# Which I can tacit expand to this:

lengths â† 0=(âŠ‘â‰¢)Â¨ list

lengths Split list

(âŠ¢-Ëœ+`Ã—Â¬) lengths

chunks â† (((+` lengths) Ã— Â¬lengths) - lengths) âŠ” list

nums â† â€¢ParseFloatÂ¨Â¨ chunks

âŒˆÂ´>+Â´Â¨ nums

# Takes an array and returns the first and last element
FirstAndLast â† { âŠâ‰(ğ•©â‰ âŒ½ğ•©)}
FirstAndLast â†• 10 # âŸ¨ 0 9 âŸ©

# âŒ½ reverses the list ğ•©
# â‰ couples the original list ğ•© with the reversed â‰ğ•©
{ğ•© â‰ âŒ½ğ•©} â†•10
# â”Œâ”€                     
# â•µ 0 1 2 3 4 5 6 7 8 9  
#   9 8 7 6 5 4 3 2 1 0  
#                      â”˜

# â‰ transposes the array
# âŠ picks the first major cell

{âŠâ‰(ğ•© â‰ âŒ½ğ•©)} â†•10

# âŸ¨0 9âŸ©

# Stole this code from a previous advent of code solution
# https://gitlab.com/icen/aoc21/-/blob/main/12.bqnâŠ£
text â† â€¢file.Lines "12.in" 
Split â† ((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)
nodes â† ({â·(Â¬ğ•©âˆŠ"start"â‹ˆ"end")/ğ•©} âˆ¾'-'âŠ¸SplitÂ¨ text) âˆ¾ <"end"
lesser â† (<"start") âˆ¾  / {âˆ§Â´ ğ•© âˆŠ 'a' + â†•26}Â¨ nodes
# the adjacency matrix should be symmetric, except for the end node which should have no outbound nodes
# and the start node, which should have no inbound nodes
adj â† {ğ•©âˆ§Â»Ë˜(â‰¢ğ•©)â¥Š1} {ğ•© âˆ§ Â¬>(-â‰ nodes)â†‘<(â‰ nodes)â¥Š1} (â‰âˆ¨âŠ¢) ({ğ•¨âˆ¾'-'âˆ¾ğ•©}âŒœËœ nodes) âˆŠ text
# If this is a terminal node, return the node unchanged
# Else join it to each outbound path
Join â† { ğ•¨ğ•ŠâŸ¨âŸ©: â‹ˆğ•¨; ğ•¨ğ•Šğ•©: (<ğ•¨) âˆ¾Â¨ ğ•© }
# Filter out any paths that have visited the same lesser node more than once
Filter â† {(Â¬> { 1 âˆŠ âŠ’ (ğ•©âˆŠlesser)/ğ•© }Â¨ğ•©)/ğ•©}
Advance â† {Filter â· âˆ¾ ğ•© JoinÂ¨ /Â¨ <Ë˜ (Â¯1âŠ‘Â¨ğ•©) âŠ adj}
_fix â† {ğ•Šâˆ˜âŠ¢âŸâ‰¢âŸœğ”½ğ•©}

p1 â† â‰ Advance _fix â‹ˆâ‹ˆ0

# Allow at most a single return to a small cave, and no double returns
Lenient â† {(> { (Â¬2âˆŠo) âˆ§ 1 â‰¥ +Â´ 1=oâ†(âŠ’ğ•©)Ã—(ğ•©âˆŠlesser) }Â¨ğ•©)/ğ•©}
Adv â† {Lenient â· âˆ¾ ğ•© JoinÂ¨ /Â¨ <Ë˜ (Â¯1âŠ‘Â¨ğ•©) âŠ adj}
p2 â† â‰  paths â† Adv _fix â‹ˆâ‹ˆ0
#â€¢ShowÂ¨ âˆ§ paths âŠÂ¨ <nodes # This is very slow on the real input
p1â€¿p2



## Breaking down this adjaceny matrix construction
adj â† {ğ•©âˆ§Â»Ë˜(â‰¢ğ•©)â¥Š1} {ğ•© âˆ§ Â¬>(-â‰ nodes)â†‘<(â‰ nodes)â¥Š1} (â‰âˆ¨âŠ¢) ({ğ•¨âˆ¾'-'âˆ¾ğ•©}âŒœËœ nodes) âˆŠ text

# This creates a square matrix of size â‰  nodes essentially making the string
# representation of the edges
{ğ•¨âˆ¾'-'âˆ¾ğ•©}âŒœËœ nodes

# this converts that matrix of text to 1s if the edge is in the input and 0 otherwise
({ğ•¨âˆ¾'-'âˆ¾ğ•©}âŒœËœ nodes) âˆŠ text

# this applies a logical or with the original and transposed matrix,
# essentially here we're making the inverse of the relations / edges
(â‰âˆ¨âŠ¢) ({ğ•¨âˆ¾'-'âˆ¾ğ•©}âŒœËœ nodes) âˆŠ text

#

# ???
{ğ•© âˆ§ Â¬>(-â‰ nodes)â†‘<(â‰ nodes)â¥Š1} (â‰âˆ¨âŠ¢) ({ğ•¨âˆ¾'-'âˆ¾ğ•©}âŒœËœ nodes) âˆŠ text